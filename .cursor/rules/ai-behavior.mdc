---
alwaysApply: true
---

# **AI 行为指导规则**

本文档指导 AI 如何编写代码、如何回答用户的问题和需求。

---

## **1️⃣ 代码生成规范**

### **1.1 前端组件生成**

* 必须生成：

  1. React 组件骨架（函数式组件 + TypeScript）
  2. 状态管理（使用 React Hooks 或 Context API）
  3. API 调用逻辑（使用 `fetch` 或项目统一的 API 封装）
  4. Ant Design 组件集成

* 根据页面类型：

  * **功能页面**：完整的页面组件，包含表单、列表、交互逻辑
  * **公共组件**：可复用的 UI 组件，支持 props 配置

### **1.2 UI生成**

* 使用 Ant Design 组件库，保持设计风格一致
* 响应式布局，适配不同屏幕尺寸
* 遵循项目的颜色主题和样式规范
* 所有 UI 文本使用中文简体

### **1.3 代码输出规范**

* **前端**：React 18 + TypeScript + Vite + Ant Design
* **后端**：FastAPI + Python 3.10 + Pydantic
* 包含模块注释、函数注释、类型定义
* 代码注释使用中文
* 变量命名使用驼峰式（前端）或下划线式（后端），含义清晰
* **错误处理完整**：任何异步逻辑（API 调用、文件操作、网络请求）必须包含 `try...catch` 或 `try...except`
  * 捕获后需使用日志记录错误与关键上下文信息，禁止吞错
* **类型明确**：TypeScript 类型应精确（不使用 `any`，必要时使用 `unknown`）；Python 使用类型注解和 Pydantic 模型
* **上下文一致**：优先使用现有封装函数与工具模块（API 服务、工具函数等）
* **遵循项目规范**：服务职责边界、端口规则、数据返回格式等，参见 `project-guide.mdc`
* **可追踪性**：若涉及多文件修改，应标注每个文件路径
* **注释规范**：复杂逻辑需添加 **JSDoc/Python docstring 风格注释**，说明作用、输入输出与潜在风险

### **1.4 后端 API 规范**

* **数据返回格式固定**：
  ```python
  {"success": True, "message": "ok", "data": {...}}
  ```
* **路由定义**：必须包含 `summary` 参数
* **异步操作**：使用 `async/await`，包裹 `try...except`
* **服务调用**：遵循服务职责边界，不跨越模块职责
* **端口规则**：
  * 标准服务：ASR=9010, LLM=9020, TTS=9030
  * 方言ASR服务：9011, 9012, ... (x从1开始递增)
  * 方言TTS服务：9031, 9032, ... (x从1开始递增)
  * LLM只有标准服务（9020），无方言服务

---

## **2️⃣ 回答用户问题的规范**

### **2.1 沟通方式**

* 使用中文简体与用户交流
* 直接编辑代码，而不是只输出修改结果
* 主动理解用户需求，避免不必要的询问
* 提供清晰、准确的解释和建议

### **2.2 代码修改规范**

* 优先使用工具直接修改代码文件
* 修改后检查 lint 错误并修复
* 保持代码风格一致性
* 确保状态管理与持久化逻辑正确

### **2.3 问题解决流程**

1. **理解需求**：仔细分析用户需求，必要时查看相关代码
2. **搜索代码库**：使用语义搜索或 grep 查找相关代码
3. **制定方案**：基于项目规范制定实现方案
4. **实施修改**：直接编辑代码文件
5. **验证检查**：检查 lint 错误，确保功能正确
6. **文档同步**：如果修改涉及架构、路径、API 变更，同步更新 `project-guide.mdc`

### **2.4 文档同步规范（⚠️ 重要）**

* **文档必须与代码保持同步**：`project-guide.mdc` 文档必须反映当前项目的实际代码结构
* **修改代码时同步更新文档**：
  * 当修改文件路径、目录结构、API 接口时，必须同步更新 `project-guide.mdc`
  * 当添加新的统一配置或工具时，必须在文档中记录
  * 当修改架构设计时，必须更新相关文档说明
* **文档验证流程**：
  1. 修改代码前，先检查文档中相关描述是否准确
  2. 修改代码后，验证文档中的路径、示例、说明是否仍然正确
  3. 如果发现文档与代码不一致，立即更新文档
* **文档检查清单**：
  - [ ] 文件路径是否准确（如 `backend/app/routers/` 是目录而非单个文件）
  - [ ] 前端组件和工具函数的位置是否正确（如 `frontend/src/components/` 目录）
  - [ ] API 接口和函数签名是否匹配
  - [ ] 目录结构描述是否完整
  - [ ] 示例代码是否能正常运行
  - [ ] 端口配置和服务地址是否正确
* **文档更新原则**：
  * ✅ **必须更新**：文件路径、目录结构、API 变更、架构调整
  * ✅ **建议更新**：新增功能说明、最佳实践更新
  * ❌ **禁止**：文档描述与实际代码不一致

---

## **3️⃣ 特殊注意事项**

### **3.1 命令行执行**

* 使用 PowerShell 语法，不支持 `&&`，命令之间使用 `;` 分隔
* 根据用户偏好，询问用户执行命令而不是直接执行

### **3.2 服务重启**

* 修改代码后不自动重启服务
* 由用户自行处理服务重启

### **3.3 UI 文本**

* 所有 UI 文本使用中文简体

### **3.4 音频处理规范**

* 仅支持 WAV 格式（后端处理时）
* 临时文件存储于 `backend/uploads/` 目录
* 音频文件通过 FastAPI 静态文件服务提供访问（`/uploads` 路径）
* 使用 `torch.no_grad()` 包裹模型推理代码
* 音频采样率：16000 Hz（根据配置调整）

### **3.5 服务调用规范**

* 后端调用子服务时，使用配置中的服务 URL（`settings.asr_service_url` 等）
* 服务配置统一从 `config/services.json` 读取，通过 `app.core.config.Settings` 访问
* LLM 服务支持自动探测本地服务（9020端口），失败时回退到云端 Provider
* 遵循服务职责边界，不跨越模块职责
* 所有服务调用必须包含超时设置和错误处理
* 前端通过统一的 API 服务层调用后端接口

### **3.6 数字嘉庚功能规范**

* 数字嘉庚使用独立的 TTS 服务（陈嘉庚TTS，9031端口）
* 支持模拟模式（`use_mock` 参数），使用 `mock_service` 进行联调演示
* 会话管理通过 `conversation_service` 处理，支持会话ID生成和历史管理
* 字幕功能通过 `subtitle_service` 提供时间轴拟合
* 音频输出存储在 `backend/uploads/` 目录，文件名格式：`jiageng_{timestamp}_{uuid}.wav`

---

## **4️⃣ 代码引用规范**

* 展示现有代码时，使用代码引用格式：`startLine:endLine:filepath`
* 展示新代码或提案时，使用标准 Markdown 代码块
* 确保代码格式正确，包含必要的上下文

---

## **5️⃣ AI 决策与判断原则**

### **5.1 三维平衡原则**

AI 在所有操作中必须遵循 **"三维平衡原则"**：

| 原则             | 描述                                        |
| -------------- | ----------------------------------------- |
| **1️⃣ 架构一致性**  | 保持前后端分离、多服务架构边界；不跨越服务职责边界（ASR/TTS/LLM/Backend/Frontend）；当有改动涉及架构层时，必须说明其"兼容性依据"。 |
| **2️⃣ 上下文感知性** | 所有建议基于当前代码上下文与模块关系；若信息不足，先提问再行动。          |
| **3️⃣ 智能适度性**  | 不盲目追求"单一职责"或"解耦"，在提升可维护性的同时保持代码自然与连贯。     |

### **5.2 AI 思考与判断层**

AI 必须在每次行动前先进行以下判断：

1. **是否必要**
   * 该修改能否显著提升可维护性或性能？
   * 若收益不明显，保留原设计。

2. **是否一致**
   * 是否与项目的既有模式（FastAPI 路由结构、React 组件结构、服务调用方式）保持一致？

3. **是否安全**
   * 是否可能引入跨进程访问、未捕获异常、异步阻塞等风险？

4. **是否清晰**
   * 新设计是否真的让后续维护者"更容易理解"？
   * 若否，宁可保持简单。

### **5.3 决策准则：何时重构 / 何时保留**

| 场景                               | 建议                  |
| -------------------------------- | ------------------- |
| 后端路由逻辑超100行且多重职责                  | ✅ 拆分为独立 router 或 service     |
| 前端组件逻辑集中但上下文强依赖（如页面内部控制流） | ⚠️ 保留整体结构，仅内部优化     |
| 临时计算、简单数据格式化                     | ❌ 不需抽离成独立模块 |
| 模型调用逻辑可被多个路由复用                    | ✅ 抽象为 `utils` 或 `service`    |
| 性能优化引入复杂度过高                      | ⚠️ 延后执行，保留清晰优先      |
| 业务约束强的模块（如服务层、状态管理）       | ✅ 仅优化内部实现，不改变接口     |

### **5.4 理念总结**

> **"最好的重构，不是最复杂的，而是最自然的。"**
>
> AI 在《闽音智聆》项目中的目标，不是展示技巧，而是**延续系统结构一致性、强化语音智能逻辑、减少未来维护负担**。

---

## **6️⃣ 代码输出格式模板**

当进行复杂修改或重构时，应遵循以下格式：

### **1. 🧭 分析与诊断 (Analysis & Diagnosis)**
> 概述你对问题的理解与分析过程，指出结构、性能或逻辑层面的核心问题。

### **2. 💡 解决方案 (Solution)**
> 描述你的重构思路与设计理由。
> 若涉及"是否需要解耦/拆分"的决策，请说明依据与收益权衡。

### **3. ✨ 代码实现 (Code Implementation)**
> 使用代码引用格式或标准 Markdown 代码块提供完整代码或差异展示。

### **4. 🚀 后续建议 (Next Steps)**
> 说明本次修改的潜在影响、可进一步优化的方向或测试验证建议。
